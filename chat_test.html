<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Чат</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', sans-serif;
      background: #f0f2f5;
      color: #333;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    #chat-header {
      background: #00838f;
      color: white;
      padding: 15px;
      text-align: center;
    }
    #messages-list {
      flex: 1;
      overflow-y: auto;
      padding: 10px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .msg-bubble {
      max-width: 70%;
      padding: 10px 14px;
      border-radius: 18px;
      margin: 4px 0;
      word-wrap: break-word;
    }
    .msg-from-me {
      background: #00838f;
      color: white;
      align-self: flex-end;
    }
    .msg-from-them {
      background: #e0e0e0;
      color: black;
      align-self: flex-start;
    }
    #chat-controls {
      display: flex;
      padding: 10px;
      gap: 10px;
      background: white;
      border-top: 1px solid #ddd;
    }
    #message-input {
      flex: 1;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 6px;
      font-size: 14px;
    }
    #send-message-btn {
      padding: 10px 16px;
      background: #00838f;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
    }
    #send-message-btn:hover {
      background: #006064;
    }
  </style>
</head>
<body>

  <div id="chat-header">
    <h3 id="chat-name">Выберите собеседника</h3>
  </div>

  <div id="messages-list"></div>

  <div id="chat-controls">
    <input type="text" id="message-input" placeholder="Введите сообщение... Используйте ’‘’‘[type]:{...}’‘’‘ для специальных блоков" />
    <button id="send-message-btn">Отправить</button>
  </div>

  <!-- Firebase SDK -->
  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js';
    import { getAuth, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/11.9.1/firebase-auth.js';
    import {
      getFirestore,
      collection,
      query,
      where,
      onSnapshot,
      addDoc,
      doc,
      getDoc,
      updateDoc,
      arrayUnion,
      getDocs
    } from 'https://www.gstatic.com/firebasejs/11.9.1/firebase-firestore.js';

    const firebaseConfig = {
      apiKey: "AIzaSyBvyxPtx5PICYk60HUCERw5Cxh1TyCcZCY",
      authDomain: "antient-9bff0.firebaseapp.com",
      projectId: "antient-9bff0",
      storageBucket: "antient-9bff0.firebasestorage.app",
      messagingSenderId: "311792589414",
      appId: "1:311792589414:web:5fff3154735007c2006ba7",
      measurementId: "G-W4ZQXWRTKK"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    let currentUser = null;
    let otherUser = null;

    // Парсер структурированных сообщений
    function parseStructuredMessage(text) {
      const pattern = /’‘’‘([\s\S]*?)’‘’‘/g;
      const parts = [];
      let lastIndex = 0;
      let match;

      while ((match = pattern.exec(text)) !== null) {
        // Текст до блока
        if (match.index > lastIndex) {
          parts.push({ type: 'text', content: text.slice(lastIndex, match.index) });
        }

        // Обработка блока
        const blockContent = match[1].trim();
        const blockData = parseBlock(blockContent);
        if (blockData) {
          parts.push({ type: 'block', content: blockData });
        } else {
          // Если парсинг провалился — показываем как есть
          parts.push({ type: 'text', content: match[0] });
        }

        lastIndex = pattern.lastIndex;
      }

      // Остаток текста
      if (lastIndex < text.length) {
        parts.push({ type: 'text', content: text.slice(lastIndex) });
      }

      return parts;
    }

    function parseBlock(content) {
      const result = {};
      const regex = /\[(\w+)\]\s*:\s*\{([^}]*)\}/g;
      let match;

      while ((match = regex.exec(content)) !== null) {
        const key = match[1].trim();
        let value = match[2].trim();

        // Удаляем внешние кавычки, если есть
        if (value.startsWith('"') && value.endsWith('"')) {
          value = value.slice(1, -1);
        }

        // Разбиваем список через запятую, если несколько элементов в фигурных скобках
        if (value.includes('","')) {
          result[key] = value.split('","').map(s => s.trim().replace(/^"|"$/g, ''));
        } else {
          result[key] = value;
        }
      }

      return Object.keys(result).length ? result : null;
    }

    function getOtherUserIdFromHash() {
      const match = window.location.hash.match(/^#chat\/([^\/]+)$/);
      return match ? match[1] : null;
    }

    function onHashChange() {
      console.log("[onHashChange] Вызвано");
      const otherUserId = getOtherUserIdFromHash();
      if (!otherUserId) {
        document.getElementById('chat-name').textContent = "Выберите собеседника";
        document.getElementById('messages-list').innerHTML = '';
        return;
      }

      if (!currentUser) {
        console.log("[onHashChange] currentUser ещё не загружен, ждём...");
        return;
      }

      console.log(`[onHashChange] Загружаем чат с пользователем: ${otherUserId}`);
      loadChatAndStartListening(otherUserId);
    }

    async function loadChatAndStartListening(otherUserId) {
      console.log(`[loadChatAndStartListening] Начало для ${otherUserId}`);
      try {
        console.log(`[loadChatAndStartListening] Запрос профиля: ${otherUserId}`);
        const userRef = doc(db, 'users', otherUserId);
        const userSnap = await getDoc(userRef);

        if (userSnap.exists()) {
          otherUser = { id: userSnap.id, ...userSnap.data() };
          document.getElementById('chat-name').textContent = otherUser.displayName || otherUser.email || 'Неизвестный';
          console.log(`[loadChatAndStartListening] Профиль загружен: ${otherUser.displayName || otherUser.email}`);
        } else {
          document.getElementById('chat-name').textContent = "Пользователь не найден";
          console.warn(`[loadChatAndStartListening] Профиль ${otherUserId} не найден`);
          return;
        }

        startListeningToMessages(otherUserId);
        markMessagesAsRead(otherUserId);
      } catch (e) {
        console.error("[loadChatAndStartListening] Ошибка:", e);
        document.getElementById('chat-name').textContent = "Ошибка подключения";
      }
    }

    function startListeningToMessages(otherUserId) {
      console.log(`[startListeningToMessages] Начало для ${otherUserId}`);
      if (!currentUser) {
        console.error("[startListeningToMessages] currentUser is null!");
        return;
      }

      const chatQuery = query(
        collection(db, 'messages'),
        where('participants', 'array-contains', currentUser.uid)
      );

      console.log(`[startListeningToMessages] Запрос сообщений для ${currentUser.uid}`);

      onSnapshot(chatQuery, (snapshot) => {
        console.log(`[onSnapshot] Получено ${snapshot.size} сообщений`);
        const messages = [];
        snapshot.forEach(doc => {
          const data = doc.data();
          if (
            data.participants.includes(currentUser.uid) &&
            data.participants.includes(otherUserId)
          ) {
            messages.push({ id: doc.id, ...data });
          }
        });

        messages.sort((a, b) => a.timestamp - b.timestamp);
        renderMessages(messages);
      }, (error) => {
        console.error("[onSnapshot] Ошибка подписки:", error);
      });
    }

    function renderMessages(msgs) {
      const list = document.getElementById('messages-list');
      list.innerHTML = '';
      
      msgs.forEach(msg => {
        const fromMe = msg.from === currentUser.uid;
        const wrapper = document.createElement('div');
        wrapper.className = 'msg-bubble ' + (fromMe ? 'msg-from-me' : 'msg-from-them');

        // Парсим сообщение
        const parsedParts = parseStructuredMessage(msg.text);

        parsedParts.forEach(part => {
          if (part.type === 'text') {
            const textNode = document.createElement('div');
            textNode.textContent = part.content;
            wrapper.appendChild(textNode);
          } else if (part.type === 'block') {
            const block = part.content;

            // --- [char]: {"雨"} ---
            if (block.char) {
              const charBox = document.createElement('div');
              charBox.style.cssText = `
                font-size: 48px;
                text-align: center;
                margin: 10px 0;
                padding: 10px;
                background: #f9f9f9;
                border: 1px solid #ddd;
                border-radius: 8px;
                font-family: "Hiragino", serif;
              `;
              charBox.textContent = Array.isArray(block.char) ? block.char[0] : block.char;
              wrapper.appendChild(charBox);
            }

            // --- [original]->[translation] + tokens ---
            else if (block.original && block.translation) {
              const card = document.createElement('div');
              card.style.cssText = `
                background: white;
                border: 1px solid #ccc;
                border-radius: 12px;
                padding: 12px;
                margin: 6px 0;
                font-family: sans-serif;
              `;

              card.innerHTML = `
                <div style="font-size:18px; font-weight:bold;">${block.original}</div>
                <div style="font-size:16px; color:#00838f; margin:8px 0;">→ ${block.translation}</div>
                ${block.tokens ? `
                  <div style="margin-top:8px; font-size:12px; color:#555;">
                    Токены: ${block.tokens.map(t => `<span style="background:#eee; padding:2px 6px; border-radius:4px; margin-right:4px;">${t}</span>`).join('')}
                  </div>
                ` : ''}
              `;
              wrapper.appendChild(card);
            }

            // --- [paragraph] с HTML и стилями ---
            else if (block.paragraph) {
              const container = document.createElement('div');
              container.style.cssText = `
                background: white;
                border: 1px solid #ddd;
                border-radius: 10px;
                padding: 15px;
                margin: 8px 0;
                font-size: 14px;
                line-height: 1.5;
              `;

              // Вставляем HTML
              container.innerHTML = block.paragraph;

              // Добавляем стили, если заданы
              if (block.style) {
                const style = document.createElement('style');
                style.textContent = block.style;
                container.appendChild(style);
              }

              wrapper.appendChild(container);
            }

            // Любой другой тип — можно расширять
            else {
              const pre = document.createElement('pre');
              pre.style.cssText = "background:#f0f0f0; padding:8px; border-radius:6px; font-size:12px;";
              pre.textContent = JSON.stringify(block, null, 2);
              wrapper.appendChild(pre);
            }
          }
        });

        // Время
        const timeDiv = document.createElement('div');
        timeDiv.style.cssText = "font-size:11px; opacity:0.7; margin-top:6px; text-align:right";
        timeDiv.textContent = new Date(msg.timestamp).toLocaleTimeString();
        wrapper.appendChild(timeDiv);

        list.appendChild(wrapper);
      });

      list.scrollTop = list.scrollHeight;
      console.log(`[renderMessages] Отрендерено ${msgs.length} сообщений`);
    }

    async function markMessagesAsRead(otherUserId) {
      console.log(`[markMessagesAsRead] Начало для ${otherUserId}`);
      if (!currentUser) {
        console.error("[markMessagesAsRead] currentUser is null!");
        return;
      }

      const q = query(
        collection(db, 'messages'),
        where('participants', 'array-contains', currentUser.uid)
      );

      console.log(`[markMessagesAsRead] Запрос к Firestore для ${currentUser.uid}`);

      try {
        const snapshot = await getDocs(q);
        console.log(`[markMessagesAsRead] Найдено ${snapshot.size} документов`);

        for (const doc of snapshot.docs) {
          const data = doc.data();
          if (
            data.participants.includes(currentUser.uid) &&
            data.participants.includes(otherUserId) &&
            (!data.seenBy || !data.seenBy.includes(currentUser.uid))
          ) {
            console.log(`[markMessagesAsRead] Обновляем seenBy для ${doc.id}`);
            try {
              await updateDoc(doc.ref, {
                seenBy: arrayUnion(currentUser.uid)
              });
              console.log(`[markMessagesAsRead] Успешно обновлён seenBy в ${doc.id}`);
            } catch (err) {
              console.error(`[markMessagesAsRead] Ошибка обновления ${doc.id}:`, err);
            }
          }
        }

        console.log("[markMessagesAsRead] Завершено");
      } catch (e) {
        console.error("[markMessagesAsRead] Критическая ошибка:", e);
      }
    }

    async function sendMessage() {
      console.log("[sendMessage] Вызвано");
      const input = document.getElementById('message-input');
      const text = input.value.trim();
      console.log(`[sendMessage] Текст: "${text}"`);

      if (!text) {
        console.warn("[sendMessage] Пустое сообщение");
        return;
      }
      if (!otherUser) {
        console.warn("[sendMessage] otherUser не определён");
        alert("Выберите собеседника");
        return;
      }
      if (!currentUser) {
        console.warn("[sendMessage] currentUser не определён");
        alert("Ошибка: пользователь не загружен");
        return;
      }

      const userPair = [currentUser.uid, otherUser.id].sort().join('_');

      const messageData = {
        from: currentUser.uid,
        to: otherUser.id,
        text: text,
        timestamp: Date.now(),
        participants: [currentUser.uid, otherUser.id],
        userPair: userPair,
        seenBy: [currentUser.uid]
      };

      console.log("[sendMessage] Отправка данных:", messageData);

      try {
        const docRef = await addDoc(collection(db, 'messages'), messageData);
        console.log(`[sendMessage] Сообщение отправлено. ID: ${docRef.id}`);
        input.value = '';
      } catch (e) {
        console.error("[sendMessage] Ошибка отправки:", e);
        alert("Не удалось отправить сообщение: " + e.message);
      }
    }

    document.getElementById('send-message-btn').addEventListener('click', () => {
      console.log("[EventListener] Кнопка 'Отправить' нажата");
      sendMessage();
    });
    document.getElementById('message-input').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        console.log("[EventListener] Enter в поле ввода");
        sendMessage();
      }
    });

    window.addEventListener('load', () => {
      console.log('[EventListener] Страница загружена. Ждём авторизации...');
      onHashChange();
    });
    window.addEventListener('hashchange', onHashChange);

    onAuthStateChanged(auth, async (user) => {
      if (user) {
        console.log(`[onAuthStateChanged] Пользователь авторизован: ${user.uid}`);
        const userDoc = await getDoc(doc(db, 'users', user.uid));
        if (userDoc.exists()) {
          currentUser = { uid: user.uid, ...userDoc.data() };
          console.log(`[onAuthStateChanged] Профиль загружен: ${currentUser.displayName || currentUser.email}`);
          onHashChange();
        } else {
          console.warn(`[onAuthStateChanged] Профиль ${user.uid} не найден`);
          alert("Профиль не найден");
          window.location.href = './index.html';
        }
      } else {
        console.log('[onAuthStateChanged] Пользователь не авторизован. Редирект.');
        window.location.href = './index.html';
      }
    });
  </script>
</body>
</html>